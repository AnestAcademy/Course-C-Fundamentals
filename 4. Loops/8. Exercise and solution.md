# Một số bài tập và phân tích hướng giải quyết

<br />

Ở bài này, chúng ta sẽ cùng nhau ôn luyện làm bài và phân tích chi tiết cách giải quyết các bài toán trong lập trình qua ví dụ cụ thể.

<br />

## Bài 1

> Kiểm tra số `n` có phải số nguyên tố hay không.

<br />

### 1. Khái niệm số nguyên tố

_Số nguyên tố là số nguyên dương có duy nhất 2 ước phân biệt là `1` và chính nó. Lưu ý: Số 1 không phải số nguyên tố do chỉ có 1 ước._

<br />

### 2. Ý tưởng kiểm tra số nguyên tố

- Nếu `n < 2`, kết luận `n` không phải số nguyên tố. Sử dụng **`if`** để kiểm tra `n`.
- Đếm số ước của `n` trong đoạn từ `2` đến căn bậc hai của `n` (sử dụng **`for`**). Nếu `n` không có ước nào trong đoạn từ `2` đến căn bậc hai của `n` thì nó là số nguyên tố (sử dụng **`if`** để kiểm tra). Ngược lại thì không phải.

<br />

### 3. Tại sao lại chỉ đếm các ước trong đoạn từ `2` đến căn của `n`?

Nếu bạn để ý thì một số nguyên `>= 2` bất kỳ sẽ luôn có số ước ở nửa đầu căn bậc 2 của nó bằng số ước ở nửa sau căn bậc 2 của nó. Cụ thể, các ước sẽ phân bố thành 2 miền từ `2 → sqrt(n)` và từ `sqrt(n) → n`.

Phân tích cụ thể:
> Với số **12**, ta có `sqrt(12) ≈ 3.464`  
> Đoạn [ 2 → 3.464 ] có ước bằng 2, tương ứng đoạn [ 3.464 → 12 ] có ước bằng 6  
> Đoạn [ 2 → 3.464 ] có ước bằng 3, tương ứng đoạn [ 3.464 → 12 ] có ước bằng 4  
> Trong đoạn [ 2 → 3.464 ] số **12** chia hết cho 2 số [ 2, 3 ] → **12** không phải là số nguyên tố.
 
> Với số **9**, ta có `sqrt(9) = 3`  
> Đoạn [ 2 → 3 ] có ước 3, tương ứng đoạn [ 3 → 9 ] có ước 3  
> Trong đoạn [ 2 → 3 ] số **9** chia hết cho 1 số [ 3 ] → **9** không phải là số nguyên tố.

> Với số **7**, ta có `sqrt(7) ≈ 2.646`  
> Trong đoạn từ [ 2 → 2.646 ] không có số nguyên nào mà **7** chia hết → **7** là số nguyên tố.

<br />

### 4. Triển khai code

Qua phân tích bên trên chúng ta có thể nhận thấy chương trình này cần kết hợp nhiều thứ đã học lại từ trước đến này bao gồm:

- Thư viện **`math.h`** cụ thể là hàm **`sqrt()`** để tính căn bậc 2.
- **`if`** để kiểm tra một số điều kiện.
- **`for`** dùng để duyệt từ `2` đến `n` để đếm số ước của `n`.

Code hoàn chỉnh:
```c
 1    #include <stdio.h>
 2    #include <math.h>
 3     
 4    int main() {
 5    
 6        int n;
 7       
 8        printf("Enter n: ");
 9        scanf("%d", &n);
10        
11        if (n < 2) {
12            printf("n is not a prime number.\n");
13            return 0;
14        }  
15        
16        int check = 1;
17        for (int i = 2; i <= sqrt(n); i++) {
18            if (n % i == 0) {
19                printf("n is not a prime number.\n");
20                check = 0;
21                break;
22            }
23        }
24        
25        if (check) {
26            printf("n a prime number.\n");
27        }  		
28    }
```

Kết quả khi chạy chương trình:
```c
Enter n: 1
n is not a prime number.
```

```c
Enter n: 11
n a prime number.
```

```c
Enter n: 12
n is not a prime number.
```

<br />

**`return`** - đây là từ khoá dùng để kết thúc một hàm xử lý, khi gặp từ khoá **`return`** thì chương trình sẽ không chạy tiếp các dòng mã bên dưới từ **`return`** nữa. Trong ví dụ trên, khi nhập `n < 2` thì chương trình sẽ chạy vào câu lệnh **`if`** (line 11) và thực hiện lệnh `return 0;` (line 13) - lúc này **chương trình sẽ kết thúc** và những dòng mã từ line 15 → line 27 sẽ **không** được thực hiện.

**`break`** - tại sao lại dùng **`break`** tại đây? Vì trong khoảng từ `2 → sqrt(n)` có thể có rất nhiều ước của `n`, chúng ra chỉ cần tìm thấy 1 ước là kết luận được `n is not a prime number` mà không cần chạy hết vòng lặp (dư thừa không cần thiết). Bạn có thể đọc lại về **`break`** [tại đây](https://github.com/AnestLearning/Course-C-Fundamentals/blob/master/4.%20Loops/5.%20break.md).


##  

© Copyright
> ANEST LEARNING  
> Join us: [Facebook groups](https://www.facebook.com/groups/anest.learning/)
